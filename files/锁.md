# 锁
## 公平锁  
ReentrantLock(true)
通过队列先来后到  
多个线程按申请的顺序来获取锁  
在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，
否作就会加入到等待队列，以后会按照FIFO的规则从队列中取到自己。  
## 非公平锁  
ReentrantLock()  
允许加塞  
多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，
在高并发的情况下，有可能会造成优先级反转或者饥饿现象  
优点：吞吐量比公平锁大  

加锁几次就要解锁几次  
```
lock.lock();
lock.lock();
lock.unlock();
程序不退出  
```
```
lock.lock();
lock.unlock();
lock.unlock();
程序抛异常  java.lang.IllegalMonitorStateException
```
## Synchronized
也是一种非公平锁

## 可重入锁（递归锁）  
同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，
在同一线程在外层方法获取锁时，在进入内层方法会自动获取锁。  
线程可以进入任意一个它已经拥有的锁所同步着的代码块  
最大作用：避免死锁  
ReentrantLock 和 Synchronized

## 自旋锁
尝试获取锁的线程不会立刻阻塞，而是采用循环的方式去获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU  

## 独占锁（写锁）
该锁一次只能被一个线程所持有。对ReentrantLock 和 Synchronized而言都是独占锁。  
## 共享锁（读锁）
该锁可以被多个线程所持有  

ReentrantReadWriteLock  读锁是共享锁，写锁是独占锁  

## 互斥锁

## CountDownLatch
计数器功能，确保一些前提任务完成后才能执行最终任务。  
让一些线程阻塞直到另一些线程完成一些列操作之后才被唤醒  
主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞。  
其他线程带哦用countDown方法会将计数器减1（调用countDown方法的线程不会被阻塞）。  
当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行。  

## CyclicBarrier
可循环使用的屏障，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程
进入屏障通过await()方法。

## Semaphore
信号量主要用于两个目的，一是用于多个共享资源的互斥操作使用，二是用于并发线程数的控制  

#Synchonized与lock区别
##Synchonized 
是JVM层面，术语JAVA关键字  
>mointorenter底层是通过monitor对象来完成，其视wait/notify等党法也依赖于monitor对象，只有再同步块或方法中才能调用wait/notify等方法  
>monitorexit   

不需要用户手动释放锁，当Synchonized代码执行完后系统会自动让线程释放对锁的占用  
不可中断，除非抛出异常或正常运行完成  
非公平锁  
没法绑定Condition，没法精确唤醒线程  

##Lock
是JAVA的实现类，是API层面
ReetrantLock需要用户手动释放锁，若没有主动释放锁，可能导致死锁现象  
可中断，设置超时方法，或调用interrupt（）方法可以中断  
默认非公平锁   
用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像Synchonized要么随机唤醒一个线程要么唤醒全部线程   

#死锁编码及定位分析
两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干预他们都将无法推进下去，如果系统资源重组，进程的资源请求都能得到满足，
死锁出现的性能就很低，否则就会因争夺优先资源而陷入死锁。   

主要原因：   
系统资源不足   
进程运行推行的顺序不合适   
资源分配不当   