# 高并发与高并行的区别：
高并发指的是多个线程同时访问同一个资源  
高并行指的是多的线程并行去做不同的事  

# volatile 
Java虚拟机提供的轻量级的同步机制  
## 1.保证可见性
某一个线程修改了主内存的值之后，让其他的线程可以立马知道，第一时间通知其他线程  
## 2.不保证原子性
原子性：保证数据的完整性和一致性，在某个线程执行某个业务时，中间不能被加塞或者被分割，需要整体完整  
## 3.有禁止指令重排
计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，  
源代码--》编译器优化的重排--》指令并行的重排--》内存系统的重排--》最终执行的指令  
单线程环境里面确保程序最终执行结果与代买顺序执行的结果一致。  
处理器在进行重排序时必须要考虑指令之间的数据依赖性。  
多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。  
### 内存屏障  
是一个CPU指令，保证了特定操作的执行顺序，保证了某些变量的内存可见性（volatile的内存可见性实现方法）  
由于编译器和处理器都能执行指令的重排优化，如果在指令间插入一条内存屏障则会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重新排序，也就是说通过
插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障会强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。  
## 单例模式DCL代码
Double check lock双端检测锁   
```
public static SingletonDemo getInstance(){
        if(instance==null){
            synchronized (SingletonDemo.class){
                //对象可能没有完成初始化
                if (instance==null){
                    //memory=allocate();    分配对象内存空间
                    //instance(memory);     初始化对象
                    //instance = memory;    设置instance指向刚分配的内存地址，此时instance!=null
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }
```
由于不存在数据依赖  
1.memory=allocate();    分配对象内存空间  
2.instance(memory);     初始化对象  
3.instance = memory;    设置instance指向刚分配的内存地址，此时instance!=null  
仅用synchronized没有解决指令重排，指令重排只会保证串行语义的执行一致性（单线程），并不会关心多线程间的语义一致性。  
当一条线程访问instance不为null式，由于instance实例未必已初始化完成，造成了线程安全性问题  
## 单例模式volatile分析
第一次判断是为了验证是否创建对象，避免多线程访问时每个线程都加锁,提升效率  
第二次判断是为了避免重复创建单例，因为可能会存在多个线程通过了第一次判断在等待锁，来创建新的实例对象。
例如：有三个线程，A与B同时调用getSingleton时，判断第一个if都为空，这时A拿到锁，进行第二层if判断，条件成立new了一个对象；由于Synchronized原因，
B在外层等待，A创建完成，释放锁，B拿到锁，进行第二层if判断，条件不成立，结束释放锁。C调用getSingleton时第一层判断不成立，直接拿到singleton对象
返回，避免进入锁，减少性能开销。
# JMM Java内存模型  
他它是一组规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

## JMM关于同步的规定  
1.线程解锁前，必须把共享变量的值刷新回主内存  
2.线程加锁前，必须读取主内存的最新值到自己的工作内存  
3.加锁解锁必须是同一把锁  
可见性、原子性、有序性   
由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而java内存模型中
规定所有变量都存储在主内存中，主内存是共享内存区域，所有线程都是可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存
拷贝到自己的工作内存空间中，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量
副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。  

# 处理速度
硬盘<内存<缓存<cpu
主内存：实指的内存（内存条）
工作内存：